pipeline {
    agent {
       label 'dotnetcore31'
    }

   //  environment {
   //      HOME = '/tmp'
   //  }

    stages {
       stage('build') {
          steps {
            //  echo 'Notify GitLab'
            //  updateGitlabCommitStatus name: 'build', state: 'pending'
             echo 'build step goes here'
             sh(script: "dotnet build Transcript.API/Transcript.API.csproj -c Release -o ./dist", returnStdout: true)
            //  updateGitlabCommitStatus name: 'build', state: 'success'
          }
       }
       stage('test') {
           steps {
               // echo 'Notify GitLab'
            //    updateGitlabCommitStatus name: 'test', state: 'pending'
               echo 'test step goes here'
               sh(script: 'dotnet test Transcript.API.Tests/Transcript.API.Tests.csproj -c Release --results-directory ./test-results --collect "Code Coverage" --logger "trx;LogFileName=test-results.xml"'
, returnStdout: true)
            //    updateGitlabCommitStatus name: 'test', state: 'success'
           }
       }
       stage('build docker image') {
          openshift.withCluster() {
            openshift.withProject() {

              // Find the build configuration associated to the application ...
              def buildconfigs = openshift.selector("bc", "${item}")
              echo "Found ${buildconfigs.count()} buildconfigs: ${buildconfigs.names()}"
              
              // Kick off any builds in parallel ...
              def builds = buildconfigs.startBuild()
              echo "Started ${builds.count()} builds: ${builds.names()}"

              timeout(WAIT_TIMEOUT) {
                // Wait for all the builds to complete ...
                // This section will exit after the last build completes.
                echo "Waiting for builds to complete ..."
                builds.withEach {
                  // untilEach and watch - do not support watching multiple named resources,
                  // so we have to feed it one at a time.
                  it.untilEach(1) {
                      echo "${it.object().status.phase} - ${it.name()}"

                      builtResult = it.object().status.phase;
                      buildName = it.name();

                      return (it.object().status.phase == "Failed" || it.object().status.phase == "Complete")
                  }
                }
              }

              if (builtResult == "Failed") {
                // slackSend channel: '#filing-gitlab',
                  //color: COLOR_MAP[currentBuild.currentResult],
                //   color: 'danger',
                //   message: "Build failed  -  Job ${env.JOB_NAME} build ${env.BUILD_NUMBER} \n More info at: ${env.BUILD_URL}"
                error("Build failed due to either a compilation error or a failed unit test(s).")
              } else {  
                echo "Builds complete ..."
              }      
            }
         }
      }
    }
   //  post {
   //      always {
   //          xunit (
   //              thresholds: [ skipped(failureThreshold: '0'), failed(failureThreshold: '0') ],
   //              tools: [ xUnitDotNet(pattern: '**/test-results.xml') ]
   //          )
   //      }
   //  }
 }